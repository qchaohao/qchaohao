- [JavaScript语言](#javascript语言)
  - [历史简介](#历史简介)
    - [作者简介](#作者简介)
    - [版本历史](#版本历史)
    - [特性特点](#特性特点)
  - [编码规范](#编码规范)
    - [命名规范](#命名规范)
    - [注释规范](#注释规范)
    - [缩进规范](#缩进规范)
  - [流程控制](#流程控制)
    - [控制语句](#控制语句)
    - [函数方法](#函数方法)
    - [空间作用](#空间作用)
  - [面向对象](#面向对象)
    - [模块打包](#模块打包)
    - [类和对象](#类和对象)
    - [错误异常](#错误异常)
  - [数据类型](#数据类型)
    - [基本类型](#基本类型)
    - [类型转换](#类型转换)
    - [内置函数](#内置函数)
  - [数字类型](#数字类型)
    - [类型介绍](#类型介绍)
    - [运算符号](#运算符号)
    - [数学函数](#数学函数)
  - [数据序列](#数据序列)
    - [序列总论](#序列总论)
    - [推导公式](#推导公式)
    - [迭代生成](#迭代生成)
  - [文本类型](#文本类型)
    - [转义字符](#转义字符)
    - [格式化](#格式化)
    - [文本函数](#文本函数)
  - [容器类型](#容器类型)
    - [列表元祖](#列表元祖)
    - [集合类型](#集合类型)
    - [字典类型](#字典类型)

---

# JavaScript语言

## 历史简介

### 作者简介

  - ***布兰登·艾奇(Brendan Eich)***，人称JS之父，注意力币(Basic Attention Token)/BAT币创始人，也是 Mozilla 基金会和火狐浏览器的联合创始人。
  - 布兰登·艾奇1961年生于美国加州的森尼维尔市，毕业于伊利诺伊大学香槟分校。1986年获取伊利诺伊大学香槟分校计算机科学硕士学位。1995年任职于网景期间，为网景浏览器开发出JavaScript，之后成为浏览器上应用最广泛的脚本语言之一。1998年布兰登协助成立mozilla，2003年在美国在线决定结束网景浏览器的开发后，布兰登协助成立了Mozilla基金会。2014年3月24日，艾奇晋升为Mozilla公司首席执行官。2014年4月3日，艾奇宣布从Mozilla离职。艾奇在他的个人博客中写道：“Mozilla的使命远超过我们任何一人，无法胜任Mozilla的领导职位”。2015年5月28日，艾奇成立Brave软件公司，这是一家互联网安全公司，已经从天使投资者募集了250万美元的早期资金。该公司的联合创始人Brian Bondy曾在Mozilla和可汗学院工作。2016年1月20日，该公司发布了Brave网页浏览器。2017年5月，Brendan Eich发起的去中心化网页浏览器“Brave”仅30秒就完成了约3千5百万美元的ICO发售。
  <img src="creator.jpg" width="200" height="200" alt="作者简介">

  <!-- ![作者简介](./creator.jpg) -->

### 版本历史

### 特性特点

  - 它于 1995 年出现在 Netscape 中（该浏览器已停止更新），并于 1997 年被 ECMA（一个标准协会）采纳。因此也称为ECMAScript。
  - JavaScript作为一种轻量级的脚本语言，已经被广泛地应用于Web页面当中，通过嵌入HTML来实现各种酷炫的动态效果，为用户提供赏心悦目的浏览效果。除此之外，也可以用于控制cookies以及基于Node.js技术进行服务器端编程。
  - javascript是甲骨文公司的注册商标，完整的JavaScript实现包含三个部分：ECMAScript，文档对象模型和浏览器对象模型。
  - 发展初期，JavaScript的标准并未确定，同期有Netscape的JavaScript，微软的JScript和CEnvi的ScriptEase三足鼎立。1997年，在ECMA(欧洲计算机制造商协会)的协调下，由Netscape、Sun、微软、Borland组成的工作组确定统一标准：ECMA-262。
  - ECMA-262 是 JavaScript 标准的官方名称。
  - ECMAScript是欧洲计算机制造商协会通过ECMA-262标准化的脚本程序设计语言。

## 编码规范

### 命名规范

  * 1.标识符第一个字符必须是字母或下划线'_'，其他由字母、数字和下划线组成并对大小写敏感。
  * 2.模块全部小写，尽量不要用下划线(除非多个单词且数量不多的情况)。将相关的类和顶级函数放在同一个模块里，不像Java没必要限制一个类一个模块。
  * 3.类名使用帕斯卡命名风格，私有类可用一个下划线开头；函数名小写用下划线隔开，私有函数在函数前加一个下划线'\_'；变量名小写，常量名大写，如有多个单词使用下划线'\_'隔开。
  * 4.文件最开始指定用什么解释器运行脚本以及解释器所在的位置"#! /usr/bin/python3"​​，或者更通用的方法是"#! /usr/bin/env python3"​，如无特殊情况必须加入"# -*- coding: utf-8 -*-"标识，"import"语句应该放在文件头部，置于模块说明及Docstring之后且置于全局变量之前。

  ```Python
  >>> import keyword  # 保留字
  >>> keyword.kwlist
  ['False', 'None', 'True', '**peg_parser**', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']
  ```

### 注释规范

  * 1.单行注释以'#'开头，多行注释或文档注释(Docstring)采用三对单引号(''')或者三对双引号(""")将注释括起来。文档注释一般出现在模块、类和函数的头部，这样通过对象的__doc__对象获取文档，编辑器和IDE也可以根据文档注释给出自动提示。
  * 2.文档注释首行不换行，如有多行末行必需换行，结束的(""")应该独占一行，除非此文档注释只有一行。文档注释不要中英文混用且不是越长越好，通常一两句话能把情况说清楚即可，所有的公共模块、函数、类、方法都应该写文档注释。私有方法不一定需要但应该在'def'后提供一个块注释来说明。

### 缩进规范

  * 1.使用"缩进"来表示代码块，缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数，一般使用4个空格进行缩进。
  * 2.在二元运算符两边各"空一格"，函数的参数列表中','之后要有空格，函数的参数列表中默认值等号两边不要添加空格；左括号之后、右括号之前不要加多余的空格；字典对象的左括号之前不要多余的空格；不要为对齐赋值语句而使用的额外空格。
  * 3.函数之间或类的方法之间用"空一行"分隔，表示一段新的代码的开始。模块级函数和类定义之间空两行，类和函数入口之间也用两行空行分隔，以突出函数入口的开始。
  * 4.如果语句很长我们可以使用反斜杠'\'来实现"换行"，二元运算符'+'、'.'等应出现在行末，长字符串也可以用此法换行。在括号中的多行语句不需要，这时有两种情况：第二行缩进到括号的起始处；第二行缩进4个空格，适用于起始括号就换行的情形。
  * 5.缩进相同的一组语句构成一个代码块我们称之代码组，像if、while、def和class这样的复合语句，首行以关键字开始以冒号':'结束，该行之后的一行或多行代码构成代码组，我们将首行及后面的代码组称为一个子句(clause)。

## 流程控制

### 控制语句
  
  * 1.条件语句是通过一条或多条语句的执行结果(True或者False)来决定执行的代码块，用elif代替else if，所以if语句的关键字为"if – elif– else"。
  * 2.循环语句有for和while，没有"do - while"循环。for循环可以遍历任何可迭代对象，如一个列表或者一个字符串。break语句可以跳出for和while的循环体，如果循环终止任何对应的循环else块将不执行；continue语句被用来跳过当前循环中的当此循环然后继续进行下一轮循环。
  * 3.循环语句可以有else子句，它在穷尽列表(以for循环)或条件变为假(以while循环)循环终止时被执行，但循环被break终止时不执行。pass一般用做占位语句什么都不做，它只在语法上需要一条语句但程序不需要任何操作时使用。
  * 4.如果你需要遍历数字序列，可以使用内置range()函数，也可以使range以指定数字开始并指定不同的增量(甚至可以是负数；有时这也叫做'步长')，您可以结合range()和len()函数以遍历一个序列的索引，还可以使用range()函数来创建一个列表。

  ```Python
    for <variable> in <sequence>:
        <statements>
    else:
        <statements>

    while <expr>:
        <statement(s)>
    else:
        <additional_statement(s)>
  ```

### 函数方法

  * 1.函数方法是组织好可重复的用来实现单一或相关联功能的代码段，分内建函数和用户自定义函数。"return[expression]"结束函数时选择性地返回一个值给调用方，不带表达式的return相当于返回None。
  * 2.函数参数传递不可更改(immutable)对象：传递的只是a的值没有影响a对象本身，如果在fun(a)内部修改a的值则是新生成一个a的对象；函数参数传递可更改(mutable)对象：是将a真正的传过去，修改后fun(a)外部的a也会受影响。
  * 3.函数参数分4种情况：默认参数是在没有传递参数时则会使用；必需参数须以正确的顺序传入函数，调用时的数量必须和声明时的一样；关键字参数在函数调用时来确定传入的参数值，允许函数调用时参数的顺序与声明时不一致；不定长参数是可能需要一个函数能处理比当初声明时更多的参数，星号'*'的参数会以元组的形式导入，两个星号'**'的参数会以字典的形式导入，基本语法如下：

  ```Python
  def functionname(formal_args, *var_args_tuple, **var_args_dict):
    "函数_文档字符串"
    function_suite
    return [expression]
  # 声明函数时参数中星号'*'可以单独出现，星号'*'后的参数必须用关键字传入:
  def f(a, b, *, c):
      return a + b + c
  ```

  * 4.匿名函数使用lambda表达式来创建，拥有自己的命名空间且不能访问自己参数列表之外或全局命名空间里的参数"lambda [arg1 [,arg2,...argn]]: expression"，我们可以将匿名函数封装在一个函数内，这样可以使用同样的代码来创建多个匿名函数：

  ```Python
  def myfunc(n):
    return lambda a: a * n

  mydoubler = myfunc(2)
  mytripler = myfunc(3)
  print(mydoubler(11))
  print(mytripler(11))
  ```

### 空间作用

  * 1.命名空间(Namespace)是从名称到对象的映射，大部分的命名空间都是通过字典来实现的。命名空间提供在项目中避免名字冲突的一种方法，各个命名空间是独立的没有任何关系，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。例如一个文件夹(目录)中可以包含多个文件夹，每个文件夹中不能有相同的文件名，但不同文件夹中的文件可以重名。
  * 2.命名空间查找顺序"局部命名空间 -> 全局命名空间 -> 内置命名空间"，命名空间的生命周期取决于对象的作用域，如对象执行完则该命名空间的生命周期结束：内置名称(built-in names)比如函数名abs、char和异常名称Exception等等；全局名称(global names)是模块中定义的名称，记录了模块的变量包括函数、类、其它导入的模块、模块级的变量和常量；局部名称(local names)是函数中定义的名称，记录了函数的变量包括函数的参数和局部定义的变量(类中定义的也是)。
  * 3.作用域就是一个程序可以直接访问命名空间的正文区域。在程序中直接访问变量，会从内到外依次访问所有的作用域直到找到，否则会报未定义的错误。定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。
  * 4.作用域一共有4种：L(Local)是最内层，包含局部变量比如一个函数/方法内部；E(Enclosing)包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数(或类)A里面又包含了一个函数B，那么对于B中的名称来说A中的作用域就为nonlocal；G(Global)是当前脚本的最外层，比如当前模块的全局变量；B(Built-in)包含了内建的变量/关键字等，最后被搜索，规则顺序：L–>E–>G–>B。
  * 5.内置作用域是通过一个名为builtin的标准模块来实现的，但是这个变量名自身并没有放入内置作用域内，所以必须导入这个文件才能够使用它。Python中只有模块(module)，类(class)以及函数(def、lambda)才会引入新的作用域，其它的代码块(如if/elif/else/、try/except、for/while等)是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问。当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字；如果要修改嵌套作用域(enclosing作用域，外层非全局作用域)中的变量则需要nonlocal关键字。

## 面向对象

### 模块打包

  * 1.模块是后缀名'.py'里包含所有定义的函数和变量的文件。模块被别的程序引入以使用该模块中的函数等功能，一个模块只会被导入一次。每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。模块除了方法定义还可以包括可执行的代码，这些代码一般用来初始化这个模块，这些代码只有在第一次被导入时才会被执行。
  * 2."import module1[,module2[, ... moduleN]"应按照顺序排列且每组之间用一个空行分隔，如果模块在当前的搜索路径就会被导入(搜索路径是解释器会先进行搜索的所有目录的列表)。"from modname import name1[, name2[, ... nameN]"从模块中导入一个指定的部分到当前命名空间中。
  * 3.搜索路径是编译或安装时确定的且安装新的库也会修改，被存储在sys.path变量中输出是一个列表，其中第一项是空串''代表当前目录，即我们执行解释器的目录(对于脚本就是运行的所在目录)，可以在脚本中修改sys.path来引入一些不在搜索路径中的模块。每个模块都有一个"\_\_name__"属性，当值是"\_\_main__"时表明该模块自身在运行，否则是被引入：

  ```python
    if __name__ == "__main__":
        print("程序自身在运行")
    else:
        print("我来自另一模块")
  ```

  * 4.包是采用"点模块名称"管理模块命名空间的形式，比如一个模块的名称是A.B，那么他表示一个包A中的子模块B，不同模块之间的全局变量不会相互影响也不用担心不同库之间的模块重名。导入时会根据sys.path中的目录来寻找这个包中包含的子目录。目录只有包含叫做"\_\_init__.py"的文件才被认作是包，是为避免滥俗的名字(如string)不小心的影响搜索路径中的有效模块，这个文件中也可包含一些初始化代码或者为"\_\_all__"变量赋值。
  * 5.当使用"from package import item"时，对应的item既可以是包里面的子模块(子包)，也可以是包里面定义的函数、类或者变量其他名称；如使用"import item.subitem.subsubitem"这种时除了最后一项都必须是包，而最后一项则可以是模块或者是包，但是不可以是类、函数或者变量的名字。
  * 6.使用"from sound.effects import \*"时会进入文件系统，找到这个包里面所有的子模块把它们都导入进来。这个方法在Windows平台上不是非常好，因为Windows是不区分大小写的。作者只能提供一个精确的包的索引：如果包定义文件"\_\_init__.py"存在一个叫做"\_\_all__"的列表变量，那么就把这个列表中的所有名字作为包内容导入，如"\_\_all__ = ["echo", "surround", "reverse"]"。
  * 7.无论是隐式还是显式相对导入都是从当前模块开始的，主模块的名字永远是"\_\_main__"，一个应用程序的主模块应当总是使用绝对路径引用。包还提供一个额外的属性"\_\_path__"，这是一个目录列表，里面每一个包含的目录都有为这个包服务的 "\_\_init__.py"，你得在其他"\_\_init__.py"被执行前定义，可以修改这个变量用来影响包含在包里面的模块和子包。

  ```Text
  sound/                          顶层包
        __init__.py               初始化sound包
        formats/                  文件格式转换子包
                __init__.py
                wavread.py
                ...
        effects/                  声音效果子包
                __init__.py
                echo.py
                ...
  ```

### 类和对象

  * 1.类(Class)是用来描述具有相同的属性和方法的对象的集合，它定义了该集合中每个对象所共有的属性和方法，对象可以包含任意数量和类型的数据；对象是通过类定义的数据结构实例，对象包括两个数据成员(类变量和实例变量)和方法，实例化是创建一个类的实例(类的具体对象)；类变量是所有对象共有，其中一个对象将它值改变其他对象得到的就是改变后的结果，而实例变量则属对象私有，某一个对象将其值改变不影响其他对象。
  * 2.继承即派生类(derived class)继承基类(base class)的字段和方法，继承也允许把一个派生类的对象作为一个基类对象对待。类的继承和多继承形式在括号内，需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，从左至右搜索(即方法在子类中未找到时，从左到右查找父类中是否包含方法)。基类名必须与派生类定义在一个作用域内。除了类还可以用表达式，基类定义在另一个模块中时这一点非常有用："class DerivedClassName(modname.BaseClassName)"。

  ```Python
  class DerivedClassName(BaseClassName1, BaseClassName2):
      <statement-1>
      ...
      <statement-N>
  ```

  * 3.如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖(override)也称方法的重写。类的方法与普通的函数只有一个特别的区别，它们必须有一个额外的第一个参数名称，按照惯例它的名称是'self'。'self'代表类的实例，代表当前对象的地址，而self.class则指向类。'self'不是关键字，我们把他换成'runoob'也是可以正常执行的。
  * 4.很多类都倾向于将对象创建为有初始状态的，因此类可能会定义一个名为"\_\_init__()"的特殊方法(构造方法)。如果在子类中需要父类的构造方法就需要显式地调用父类的构造方法，或者不重写父类的构造方法。子类不重写"\_\_init__()"实例化子类时会自动调用父类定义的，如果重写了就不会调用父类已经定义的，如果重写了又要继承父类的构造方法可以使用'super'关键字"super(子类, self).\_\_init__(参数1, 参数2, ....)"，还有一种写法"父类名称.\_\_init__(self, 参数1, 参数2, ...)"。
  * 5.两个下划线开头声明该属性、方法为私有不能在类地外部被调用，在类内部的调用时用self.__attrs，self.__method。类的专有方法(魔术方法)有构造和初始化，__new__是第一个被调用的方法，__new__是用来创建类并返回这个类的实例, 而__init__只是将传入的参数来初始化该实例。两个共同构成了"构造函数"。在对象生命周期调用结束时，__del__方法会被调用，可以将__del__理解为"析构函数"。

  | 基本函数 | 描述 |
  | --- | --- |
  | \_\_new__(cls[, ...]) | 对象实例化的时候所调用的第一个方法 |
  | \_\_init__(self[, ...]) | 构造器，当实例被创建的时候调用的初始化方法 |
  | \_\_del__(self) | 析构器，当实例被销毁的时候调用的方法 |
  | \_\_call__(self[, args...]) | 允许类的实例像函数一样被调用：x(a, b)调用 x.\_\_call__(a, b) |

  * 6.控制属性访问通过魔术方法来完成真正封装(定义私有变量然后定义公共的getter和setter)。"\_\_getattr__(self, name)"定义当用户试图获取一个不存在的属性时的行为，这适用于对普通拼写错误的获取和重定向，对获取一些不建议的属性时候给出警告(如果你愿意你也可以计算并且给出一个值)或者处理一个AttributeError，只有当调用不存在的属性的时候会被返回。"\_\_setattr__(self, name, value)"是一个封装的解决方案，无论属性是否存在都允许你定义对属性的赋值行为，对属性的值进行个性定制，实现__setattr__时要避免"无限递归"的错误。"\_\_delattr__"功能是删除一个属性而不是设置他们，实现时也要防止无限递归现象发生。"\_\_getattribute__(self, name)"定义了你的属性被访问时的行为，相比较__getattr__只有该属性不存在时才会起作用，调用__getattr__前必定会调用__getattribute__，同样要避免"无限递归"的错误，最好不要尝试去实现因为很少见到这种做法且很容易出bug。
  * 7.自定义容器可以让你的类行为向内置容器类型一样，比如list、dict、tuple、string等等。协议跟其他语言中所谓的"接口"概念很像，很不正式的不需要明确声明实现，它给你很多你必须定义的方法，他们更像一种指南。实现不可变容器协议，你只能定义__len__和__getitem__；可变容器协议则另外还需要__setitem__和__delitem__。如果你希望你的对象是可迭代的话，你需要定义__iter__会返回一个迭代器。迭代器必须遵循迭代器协议，需要有__iter__(返回它本身)和next。

  | 基本函数 | 描述 |
  | --- | --- |
  | \_\_len__(self) | 返回容器的长度，对于可变和不可变容器的协议这都是其中的一部分 |
  | \_\_getitem__(self, key) | 定义当某一项被访问时使用self[key]所产生的行为，这也是不可变容器和可变容器协议的一部分。如果键的类型错误将产生TypeError；如果key没有合适的值则产生KeyError |
  | \_\_setitem__(self, key, value) | 当执行self[key] = value时调用的是该方法 |
  | \_\_delitem__(self, key) | 定义当一个项目被删除时的行为(del self[key])，这只是可变容器协议中的一部分，当使用一个无效的键时应该抛出适当的异常 |
  | \_\_iter__(self) | 返回一个容器迭代器很多情况下会返回迭代器，尤其是当内置的iter()方法被调用的时候，以及当使用for x in container方式循环的时候。迭代器是它们本身的对象，它们必须定义返回self的__iter__方法 |
  | \_\_reversed__(self) | 实现当reversed()被调用时的行为，应该返回序列反转后的版本。仅当序列可以是有序的时候实现它，例如对于列表或者元组 |
  | \_\_contains__(self, item) | 定义了调用in和not in来测试成员是否存在的时候所产生的行为，你可能会问为什么这个不是序列协议的一部分？因为当__contains__没有被定义的时候，如果没有定义，那么Python会迭代容器中的元素来一个一个比较，从而决定返回True或者False |
  | \_\_missing__(self, key) | dict字典类型会有该方法，它定义了key如果在容器中找不到时触发的行为。比如d = {'a': 1}当执行d[notexist]时，d.\_\_missing__['notexist']就会被调用 |

  * 8.上下文管理器在with声明的代码段中，可以做一些对象的开始操作和退出操作还能对异常进行处理，这需要实现两个魔术方法\_\_enter__和\_\_exit__。"\_\_enter__(self)"定义了当使用with语句的时候会话管理器在被初始创建时要产生的行为，返回值与with语句的目标或者as后的名字绑定。"\_\_exit__(self, exception_type, exception_value, traceback)"定义了当一个代码块被执行或者终止后会话管理器应该做什么，它可以被用来处理异常、执行清理工作或做一些代码块执行完毕之后的日常工作。如果代码块执行成功exception_type，exception_value和traceback将会为None，否则你可以选择处理这个异常或者是直接交给用户处理。如果你想处理这个异常的话，请确保\_\_exit__在所有语句结束之后返回True。如果你想让异常被会话管理器处理的话，那么就让其产生该异常。
  * 9.描述器是通过获取、设置以及删除的时候被访问的类，当然也可以改变其它的对象。描述器并不是独立的，相反它意味着被一个所有者类持有。当创建面向对象的数据库或者类，里面含有相互依赖的属相时，描述器将会非常有用。一种典型的使用方法是用不同的单位表示同一个数值，或者表示某个数据的附加属性。为了成为一个描述器，一个类必须至少有\_\_get__，\_\_set__，\_\_delete__方法被实现。"\_\_get__(self, instance, owner)"定义了当描述器的值被取得的时候的行为，instance是拥有该描述器对象的一个实例，owner是拥有者本身。"\_\_set__(self, instance, value)"定义了当描述器的值被改变的时候的行为，instance是拥有该描述器类的一个实例，value是要设置的值。"\_\_delete__(self, instance)"定义了当描述器的值被删除的时候的行为，instance是拥有该描述器对象的一个实例。
  * 10.复制对象尤其是当处理可变对象时可能想要对其做出一些改变而不希望影响原来的对象。"\_\_copy__(self)"返回了对象的一个浅拷贝。"\_\_deepcopy__(self, memodict={})"返回了对象的一个深拷贝，对象和其数据都被拷贝了。memodict是对之前被拷贝的对象的一个缓存，这优化了拷贝过程并且阻止了对递归数据结构拷贝时的无限递归。当你想要进行对一个单独的属性进行深拷贝时调用copy.deepcopy()，并以memodict为第一个参数。可以控制使用内置函数isinstance()和issubclass()反射定义魔术方法。"\_\_instancecheck__(self, instance)"检查一个实例是不是你定义的类的实例，"\_\_subclasscheck__(self, subclass)"检查一个类是不是你定义的类的子类。

  ```
  python 装饰器就是这个用处

  面向切面编程（AOP是Aspect Oriented Program的首字母缩写） ，我们知道，面向对象的特点是继承、多态和封装。而封装就要求将功能分散到不同的对象中去，
  这在软件设计中往往称为职责分配。实际上也就是说，让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可重用。
  但是人们也发现，在分散代码的同时，也增加了代码的重复性。什么意思呢？比如说，我们在两个类中，可能都需要在每个方法中做日志。按面向对象的设计方法，
  我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但就是因为面向对象的设计让类与类之间无法联系，而不能将这些重复的代码统一起来。
  也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，
  它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。
  一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，
  等到需要时再切入对象中去，从而改变其原有的行为。这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。
  有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的。
  AOP在编程历史上可以说是里程碑式的，对OOP编程是一种十分有益的补充。
  ```

### 错误异常

  * 1.语法错误为解析错，运行期检测到的错误为异常。大多数异常都不会被程序处理，都以错误信息的形式展现。错误信息的前面部分显示了异常发生的上下文，并以调用栈的形式显示具体信息；assert(断言)用于判断一个表达式，在表达式条件为False的时候触发异常。断言可以在条件不满足程序运行的情况下直接返回错误，而不必等待程序运行后出现崩溃的情况，例如我们的代码只能在Linux系统下运行，可以先判断当前系统是否符合条件。

  ```Python
  assert expression[, arguments]
  # 等价于：
  if not expression:
      raise AssertionError(arguments)
  ```

  * 2."try/except"语句先执行try子句，如没有异常发生忽略except子句，如果发生异常那么对应的except子句将被执行。一个try语句可能包含多个except子句分别来处理不同的特定的异常，最多只有一个分支会被执行。一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组"except (RuntimeError, TypeError, NameError)"。最后的except子句可忽略异常的名称并将被当作通配符使用，可使用此方法打印一个错误信息然后再次把异常抛出；"try/except...else"语句将在try子句没有发生任何异常的时候执行，使用else子句比把所有的语句都放在try子句里面要好，这样可以避免一些意想不到而except又无法捕获的异常；"try/except...finally"语句无论是否发生异常都将执行最后的代码。
  * 3.使用raise语句抛出一个指定的异常"raise [Exception[, args[, traceback]]]"，raise唯一的一个参数指定了要被抛出的异常，它必须是一个异常的实例或者是异常的类(也就是Exception的子类)。如果你只想知道这是否抛出了一个异常并不想去处理它，那么一个简单的raise语句就可以再次把它抛出。用户自定义异常通过创建一个新的异常类来拥有自己的异常，异常类继承自Exception类，可以直接继承或者间接继承。异常的类可以像其他的类一样做任何事情，但是通常都会比较简单只提供一些错误相关的属性，并且允许处理异常的代码方便的获取这些信息。当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类。

  ```Python
    class MyError(Exception):
        def __init__(self, value):
            self.value = value
        def __str__(self):
            return repr(self.value)
  ```

  * 4.with语句用于异常处理，封装了"try/except...finally"编码范式，提高了易用性、可读性，简化了文件流等公共资源的管理，在处理文件对象时使用with关键字是一种很好的做法，不会因为执行异常而占用资源。with语句实现原理建立在上下文管理器之上，上下文管理器是一个实现\_\_enter__和\_\_exit__方法的类。使用with语句确保在嵌套块的末尾调用\_\_exit__方法，这个概念类似于"try/except...finally"块的使用，在文件对象中定义了\_\_enter__和\_\_exit__方法，即文件对象也实现了上下文管理器，首先调用\_\_enter__方法，然后执行with语句中的代码，最后调用\_\_exit__方法，即使出现错误也会调用，也就是会关闭文件流。

## 数据类型

### 基本类型

  * 1.变量不需要声明且没有类型，仅是一个对象的引用(一个指针)，我们所说的"类型"是变量所指的内存中对象的类型，变量在使用前都必须赋值，赋值以后该变量才会被创建，等号'='用来给变量赋值，可以同时为多个变量赋值如a, b = 1, 2。
  * 2.六个标准的数据类型，不可变数据3个：Number(数字)、String(字符串)、Tuple(元组)；可变数据3个：List(列表)、Set(集合)、Dictionary(字典)。
  * 3.可变和不可变是相对于引用地址来说的：不可变类型不允许变量的值发生变化，如果改变了变量的值相当于新建了一个对象，而对于相同的值的对象内部会有一个引用计数来记录有多少个变量引用了这个对象；可变类型允许变量的值发生变化，对变量进行修改操作只会改变变量的值不会新建对象，变量引用的地址也不会发生变化，不过对于相同的值的不同对象在内存中则会存在不同的对象，即每个对象都有自己的地址，相当于内存中对于同值的对象保存了多份，这里不存在引用计数是实实在在的对象。
  * 4.isinstance()和type()的区别在于：type()不会认为子类是一种父类类型；isinstance()会认为子类是一种父类类型。

  | 数据类型 | 描述 |
  | --- | --- |
  | str | 文本 |
  | int, float, complex | 数字 |
  | list, tuple, range | 序列 |
  | dict | 映射 |
  | set, frozenset | 集合 |
  | bool | 布尔值 |
  | bytes, bytearray, memoryview | 二进制 |

### 类型转换

  * 1.有时候我们需要对数据内置的类型进行转换，只需将数据类型作为函数名即可，这些函数返回一个新的对象表示转换的值。数据类型转换可以分为两种：隐式类型转换是自动完成，较低数据类型(整数)就会转换为较高数据类型(浮点数)以避免数据丢失；显式类型转换，需要使用类型函数来转换。

  | 函数 | 描述 |
  | --- | --- |
  | int(x[, base]) | 将x转换为一个整数 |
  | float(x) | 将x转换到一个浮点数 |
  | complex(real[, imag]) | 创建一个复数 |
  | str(x) | 将对象x转换为字符串 |
  | repr(x) | 将对象x转换为表达式字符串 |
  | eval(str) | 用来计算在字符串中的有效Python表达式，并返回一个对象 |
  | tuple(s) | 将序列s转换为一个元组 |
  | list(s) | 将序列s转换为一个列表 |
  | set(s) | 转换为可变集合 |
  | frozenset(s) | 转换为不可变集合 |
  | dict(d) | 创建一个字典。d必须是一个(key, value)元组序列 |
  | chr(x) | 将一个整数转换为一个字符 |
  | ord(x) | 将一个字符转换为它的整数值 |
  | hex(x) | 将一个整数转换为一个十六进制字符串 |
  | oct(x) | 将一个整数转换为一个八进制字符串 |

### 内置函数

help()	setattr()
all()	dir()	next()	slice()
any()	divmod()	id()	object()	
ascii()	input()	staticmethod()
bin()	eval()	open()
bool()	exec()	sum()
bytearray()	filter()	pow()	super()
bytes()	iter()	print()	
callable()	format()	property() range()	vars()
classmethod()	getattr()	locals()
compile()	globals()	map()	__import__()
complex()	hasattr()	reload()
delattr()	hash()	memoryview()

## 数字类型

### 类型介绍

  * 1.数字类型用于数值的储存且数值类型是不许改变的，如改变数字数据类型的值将重新分配内存空间。支持三种不同的数值类型：整型(Int)通常被称为是整型或整数，是正或负整数不带小数点，整型是没有限制大小的可当Long类型使用，所以Python3没有Python2的Long类型；浮点型(float)由整数部分与小数部分组成，也可用科学计数法表示(2.5e2 = 2.5 x 102 = 250)；复数(complex)由实数部分和虚数部分构成，可用a + bj或者complex(a, b)表示，复数的实部a和虚部b都是浮点型。

  ```Python
  # 可用十六进制和八进制来代表整数：
  >>> number = 0xA0F # 十六进制
  >>> 2575
  >>> number=0o37 # 八进制
  >>> 31

  # 在交互模式中最后被输出的表达式结果被赋值给变量'_'，'_'变量应被用户视为只读变量：
  >>> tax = 12.5 / 100
  >>> price = 100.50
  >>> price * tax
  12.5625
  >>> price + _
  113.0625
  >>> round(_, 2)
  113.06
  ```

### 运算符号

  * 1.式子"4 + 5 = 9"中'4'和'5'被称为操作数，'+'称为运算符。支持7种运算符：算术运算符，比较(关系)运算符，赋值运算符，逻辑运算符，位运算符，成员运算符，身份运算符。
  * 2.算术运算符包括'+'加，'-'减，'\*'乘，'/'除，'%'取模，'\*\*'幂，'//'取整除；比较运算符包括'=='等于，'!='不等于，'>'大于，'<'小于，'>='大于等于，'<='小于等于；赋值运算符包括'='简单赋值，'+='加法赋值，'-='减法赋值，'*='乘法赋值，'/='除法赋值，'%='取模赋值，'\*\*='幂赋值，'//='取整除赋值；成员运算符包括'in'如果在指定序列中找到值返回True否则返回False，'not in'如果在指定序列中没有找到值返回True否则返回True；身份运算符用于比较两个对象的存储单元，'is'是判断两个标识符是不是引用自一个对象，'is not'是判断两个标识符是不是引用自不同对象，'is'与'=='区别是'is'用于判断两个变量引用对象是否为同一个，'=='用于判断引用变量的值是否相等。
  * 3.逻辑运算符，以下假设变量a为10, b为20:

  | 运算符 | 逻辑表达式 | 描述 | 实例 |
  | --- | --- | --- | --- |
  | and | x and y | 布尔"与"，如果x为False，返回x的值否则返回y的计算值 | (a and b)返回20 |
  | or | x or y | 布尔"或"，如果x为True，返回x的值否则返回y的计算值 | (a or b)返回10 |
  | not | not x | 布尔"非"，如果x为True返回False，如果x为False返回True | not(a and b)返回False |

  * 4.按位运算符是把数字看作二进制来进行计算的，下表中变量a为60，b为13，二进制格式a为0011 1100，b为0000 1101。假设机器字长为n，原码就是用一个n位的二进制数，其最高位为符号位，正数是0负数是1，剩下的表示概数的绝对值，位数如果不够就用0补全；反码在原码的基础上，符号位不变其他位取反，也就是0变1，1变0；补码在反码的基础上加1。正数的原、反、补码都一样，0的原码跟反码都有两个，因为这里0被分为'+0'和'-0'。按位取反和反码有一定的相似之处但又不尽相同(反码符号位不取反)。在计算机中是以补码的形式存放数据的，1100 0011刚好对应-61(注意-61需要使用九位来进行存储，其中八位存储数据，一位为符号位，下文的原码转反码运算可以看出第八位是用来进行数据存储的，所以不能作为符号位)。-61的原码->1 0011 1101->反码->1 1100 0010->补码->1 1100 0011(第一位为符号位)。

  | 运算符 | 描述 | 实例 |
  | --- | --- | --- |
  | & | 按位与运算符：参与运算的两个值如果两个相应位都为1，则该位的结果为1否则为0 | (a & b)输出结果12，二进制解释：0000 1100 |
  | \| | 按位或运算符：只要对应的二个二进位有一个为1时结果位就为1 | (a \| b)输出结果61，二进制解释：0011 1101 |
  | ^ | 按位异或运算符：当两对应的二进位相异(不同)时结果为1 | (a ^ b)输出结果49，二进制解释：0011 0001 |
  | ~ | 按位取反运算符：对数据的每个二进制位取反，即把1变为0，把0变为1 | (~a)输出结果-61，二进制解释：1100 0011 |
  | << | 左移动运算符：运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，高位丢弃低位补0 | a << 2输出结果240，二进制解释：1111 0000 |
  | >> | 右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数 | a >> 2输出结果15，二进制解释：0000 1111 |

  * 5.运算符优先级是同一级运算符的优先级从左往右进行计算，括号因为不是运算符所以没有纳入本表，但算术式中一旦出现括号，就要先算括号内的内容。

  | 运算符 | 描述 |
  | --- | --- |
  | ** | 指数(最高优先级) |
  | ~ + - | 按位翻转，一元加号和减号(最后两个的方法名为+@和-@）|
  | * / % // | 乘，除，取模和取整除 |
  | + - | 加法减法 |
  | >> << | 右移，左移运算符 |
  | & | 位'AND' |
  | ^ \| | 位运算符 |
  | <= < > >= | 比较运算符 |
  | == != | 比较运算符 |
  | = %= /= //= -= += *= **= | 赋值运算符 |
  | is is not | 身份运算符 |
  | in not in | 成员运算符 |
  | not and or | 逻辑运算符 |

### 数学函数

  * 1.基本数学函数"abs(x)"返回数字的绝对值，如abs(-10)返回10；"max(x1, x2,...)"返回给定参数的最大值，参数可以为序列；"min(x1, x2,...)"返回给定参数的最小值，参数可以为序列；"round(x[, n])"返回浮点数x的四舍五入值，如给出n值则代表舍入到小数点后的位数，其实准确的说是保留值将保留到离上一位更近的一端。
  * 2."random"模块包括随机数函数"choice(seq)"从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数；"randrange([start,] stop [,step])"从指定范围内按指定基数递增的集合中获取一个随机数，基数默认值为1；"random()"随机生成下一个实数，它在\[0,1\)范围内；"seed([x])"改变随机数生成器的种子seed，如果不了解其原理不必特别去设定seed，Python会帮你选择seed；"shuffle(lst)"将序列的所有元素随机排序；"uniform(x, y)"随机生成下一个实数，它在[x, y]范围内。
  * 3."math"模块包括数学函数"ceil(x)"返回数字的上入整数，如math.ceil(4.1)返回5；"floor(x)"返回数字的下舍整数，如math.floor(4.9)返回4；"exp(x)"返回e的x次幂(e**x)，如math.exp(1)返回2.718281828459045；"pow(x, y)"返回x\*\*y运算后的值；"fabs(x)"返回数字的绝对值，如math.fabs(-10)返回10.0；"log(x)"如math.log(math.e)返回1.0,math.log(100, 10)返回2.0；"log10(x)"返回以10为基数的x的对数，如math.log10(100)返回2.0；"modf(x)"返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示；"sqrt(x)"返回数字x的平方根。
  * 4."math"模块包括三角函数"sin(x)"返回x弧度的正弦值；"cos(x)"返回x弧度的余弦值；"asin(x)"返回x的反正弦弧度值；"acos(x)"返回x的反余弦弧度值；"tan(x)"返回x弧度的正切值；"atan(x)"返回x的反正切弧度值；"atan2(y, x)"返回给定的X及Y坐标值的反正切值；"hypot(x, y)"返回欧几里德范数sqrt(x\*x + y\*y)；"degrees(x)"将弧度转换为角度，如degrees(math.pi/2)返回90.0；"radians(x)"将角度转换为弧度。

## 数据序列

### 序列总论

  * 1.在编程语言中将以某种方式（比如通过编号）组合起来的数据元素（如数字，字符串乃至其他数据结构）集合称为数据结构，在python中最基本的数据结构为序列（sequence，简写为seq）。序列指的是一块可存放多个值的连续内存空间，这些值按一定顺序排列，可通过每个值所在位置的编号（称为索引）访问它们。在Python中​​序列类型包括字符串、列表、元组、集合和字典​​，但比较特殊的是集合和字典不支持索引、切片、相加和相乘操作。
  * 2.序列中每个元素都有自己的编号（索引），索引值从0开始递增[0, 1, 2, ..., n-1]，负数索引值是从右向左计数，从索引值-1开始递减[-n, -(n-1), -(n-2), ..., -1]。切片操作是访问序列中元素的另一种方法，它可以访问一定范围内的元素，通过切片操作可以生成一个新的序列，序列实现切片操作的语法格式如下"sname[start : end : step]"，sname表示序列的名称；start表示切片的开始索引位置（包括该位置），此参数也可以不指定会默认为0，也就是从序列的开头进行切片；end表示切片的结束索引位置（不包括该位置），如果不指定则默认为序列的长度；step表示在切片过程中，隔几个存储位置（包含当前位置）取一次元素，也就是说如果step的值大于1，则在进行切片去序列元素时会"跳跃式"的取元素，如果省略设置step的值则最后一个冒号就可以省略。如果是负数的话则表示逆序取，如mystr[::-1]表示的是获取反向字符串。
  * 3.序列相加支持两种类型相同的序列使用'+'运算符做相加操作，它会将两个序列进行连接但不会去除重复的元素。序列相乘'*'是使用数字n乘以一个序列会生成新的序列，其内容为原来序列被重复n次的结果。可以使用in和not in检查某元素是否为序列的成员。和序列相关的内置函数如下：

  | 函数 | 功能 |
  | --- | --- |
  | len() | 计算序列的长度即返回序列中包含多少个元素 |
  | max() | 找出序列中的最大元素。注意对序列使用sum()函数时，做加和操作的必须都是数字，不能是字符或字符串，否则该函数将抛出异常，因为解释器无法判定是要做连接操作（+运算符可以连接两个序列）还是做加和操作 |
  | min() | 找出序列中的最小元素 |
  | list() | 将序列转换为列表 |
  | str() | 将序列转换为字符串 |
  | sum() | 计算元素和 |
  | sorted() | 对元素进行排序 |
  | reversed() | 反向序列中的元素 |
  | enumerate() | 将序列组合为一个索引序列，多用在for循环中 |

### 推导公式

  * 1.推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体，支持列表(list)推导式、元组(tuple)推导式、集合(set)推导式、字典(dict)推导式，一般格式为"[表达式 for 变量 in 列表 (if 条件)]"。元组推导式可以利用range区间、元组、列表、字典和集合等数据类型快速生成一个满足指定需求的元组，元组推导式返回的结果是一个生成器对象。

  ```Python
  # 列表推导式：[out_exp_res for out_exp in input_list (if condition)]
  # out_exp_res：列表生成元素表达式，可以是有返回值的函数。
  # for out_exp in input_list：迭代input_list将out_exp传入到out_exp_res表达式中。
  # if condition：条件语句，可以过滤列表中不符合条件的值。

  # 过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母：
  >>> names = ['Bob','Tom','alice','Jerry','Wendy','Smith']
  >>> new_names = [name.upper() for name in names if len(name) > 3]
  >>> ['ALICE', 'JERRY', 'WENDY', 'SMITH']
  # 计算30以内可以被3整除的整数：
  >>> multiples = [i for i in range(30) if i % 3 == 0]
  >>> [0, 3, 6, 9, 12, 15, 18, 21, 24, 27]

  # 元组推导式：(expression for item in Sequence (if conditional))
  # 我们可以使用下面的代码生成一个包含数字1 ~ 9的元组：
  >>> a = (x for x in range(1, 10))
  >>> <generator object <genexpr> at 0x7faf6ee20a50>  # 返回的是生成器对象

  # 集合推导式：{expression for item in Sequence (if conditional)}
  >>> setnew = {i**2 for i in (1, 2, 3)} # 计算数字1, 2, 3的平方数
  >>> {1, 4, 9}
  # 判断不是abc的字母并输出：
  >>> a = {x for x in 'abracadabra' if x not in 'abc'}
  >>> {'d', 'r'}

  # 字典推导式：{key_expr: value_expr for value in collection (if condition)}
  # 将列表中各字符串值为键，各字符串的长度为值组成键值对：
  listdemo = ['Google','Runoob', 'Taobao']
  >>> newdict = {key: len(key) for key in listdemo}
  >>> {'Google': 6, 'Runoob': 6, 'Taobao': 6}
  # 提供三个数字，以三个数字为键，三个数字的平方为值来创建字典：
  >>> dic = {x: x**2 for x in (2, 4, 6)}
  >>> {2: 4, 4: 16, 6: 36}
  ```

### 迭代生成

  * 1.迭代器是个可记住遍历位置的对象，是访问集合元素的一种方式，迭代器只能往前不会后退，迭代器对象从集合的第一个元素开始访问直到所有的元素被访问完结束。迭代器有两个基本的方法iter()和next()，字符串、列表或元组对象都可用于创建迭代器。

  ```Python
  >>> list=[1,2,3,4]
  >>> it = iter(list)    # 创建迭代器对象
  >>> print (next(it))   # 输出迭代器的下一个元素
  # 迭代器对象可以使用常规for语句进行遍历：
  list=[1,2,3,4]
  it = iter(list)    # 创建迭代器对象
  for x in it:
      print (x, end=" ")
  # 也可以使用next()函数：
  import sys         # 引入 sys 模块
  list=[1,2,3,4]
  it = iter(list)    # 创建迭代器对象
  while True:
      try:
          print (next(it))
      except StopIteration:
          sys.exit()
  ```

  * 2.类作为一个迭代器使用需实现两个方法，\_\_iter__()方法返回一个特殊的迭代器对象，这个迭代器对象实现了\_\_next__()方法并通过StopIteration异常标识迭代的完成，\_\_next__()方法会返回下一个迭代器对象。StopIteration异常用于标识迭代的完成防止出现无限循环的情况，在\_\_next__()方法中可以设置在完成指定循环次数后触发StopIteration异常来结束迭代。

  ```Python
  # 创建一个返回数字的迭代器，初始值为1逐步递增1：
  class MyNumbers:
    def __iter__(self):
      self.a = 1
      return self
  
    def __next__(self):
      x = self.a
      self.a += 1
      return x
  
  myclass = MyNumbers()
  myiter = iter(myclass)
  print(next(myiter))

  # 在 20 次迭代后停止执行：
  class MyNumbers:
    def __iter__(self):
      self.a = 1
      return self
  
    def __next__(self):
      if self.a <= 20:
        x = self.a
        self.a += 1
        return x
      else:
        raise StopIteration
  
  myclass = MyNumbers()
  myiter = iter(myclass)
  for x in myiter:
    print(x)
  ```

  * 3.生成器是使用了yield的函数（generator），跟普通函数不同的是生成器是一个返回迭代器的函数只能用于迭代操作，生成器就是一个迭代器。在调用生成器运行的过程中每次遇到yield时函数会暂停并保存当前所有的运行信息，返回yield的值并在下一次执行next()方法时从当前位置继续运行。调用一个生成器函数返回的是一个迭代器对象。如果没有return则默认执行至函数完毕，如果在执行过程中return则直接抛出StopIteration终止迭代。

  ```Python
  import sys
  def fibonacci(n): # 生成器函数 - 斐波那契
      a, b, counter = 0, 1, 0
      while True:
          if (counter > n): 
              return
          yield a
          a, b = b, a + b
          counter += 1

  f = fibonacci(10) # f 是一个迭代器，由生成器返回生成

  while True:
      try:
          print (next(f), end=" ")
      except StopIteration:
          sys.exit()
  # 执行以上程序，输出结果如下：
  0 1 1 2 3 5 8 13 21 34 55
  ```

## 文本类型

### 转义字符

  * 1.没有单独的字符类型，一个字符就是长度为1的字符串；用单引号（''）或双引号（""）括起来，同时使用反斜杠'\'转义特殊字符；如果你不想让反斜杠发生转义，可以在字符串前面添加一个'r/R'，表示原始字符串。与C不同的是字符串不能被改变，向一个索引位置赋值会导致错误。'\'（在行尾时）续行符；'\\'反斜杠符号；"\'"单引号；'\"'双引号；'\a'响铃；'\b'退格(Backspace)；'\000'空；'\n'换行；'\v'纵向制表符；'\t'横向制表符；'\f'换页；'\r'回车，将'\r'后面的内容移到字符串开头，并逐一替换开头部分的字符，直至将'\r'后面的内容完全替换完成；	'\yyy'八进制数，y代表0~7的字符，例如'\012'代表换行；'\xyy'十六进制数，以'\x'开头，y代表的字符，例如'\x0a'代表换行；'\other'其它的字符以普通格式输出。

### 格式化
  
  * 1.尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符'%s'的字符串中。在Python中字符串格式化使用与C中sprintf函数一样的语法。
  
  ```Python
  #!/usr/bin/python3 
  print("我叫 %s 今年 %d 岁!" % ('小明', 10))
  以上实例输出结果：
  我叫 小明 今年 10 岁!
  ```

  | 符号 | 描述 |
  | --- | --- |
  | %c | 格式化字符及其ASCII码 |
  | %s | 格式化字符串 |
  | %d | 格式化整型 |
  | %u | 格式化无符号整型 |
  | %o | 格式化无符号八进制数 |
  | %x | 格式化无符号十六进制数 |
  | %X | 格式化无符号十六进制数（大写） |
  | %f | 格式化浮点数字，可指定小数点后的精度 |
  | %e | 用科学计数法格式化浮点数 |
  | %E | 作用同%e，用科学计数法格式化浮点数 |
  | %g | %f和%e的简写 |
  | %G | %f和%E的简写 |
  | %p | 用十六进制数格式化变量的地址 |

  * 格式化操作符辅助指令:
  
  | 符号 | 功能 |
  | --- | --- |
  | * | 定义宽度或者小数点精度 |
  | - | 用做左对齐 |
  | + | 在正数前面显示加号(+) |
  | \<sp> | 在正数前面显示空格 |
  | # | 在八进制数前面显示零('0')，在十六进制前面显示'0x'或者'0X'(取决于用的是'x'还是'X') |
  | 0 | 显示的数字前面填充'0'而不是默认的空格 |
  | % | '%%'输出一个单一的'%' |
  | (var) | 映射变量(字典参数) |
  | m.n. | m是显示的最小总宽度，n是小数点后的位数(如果可用的话) |

  * Python2.6开始新增了一种格式化字符串的函数str.format()，它增强了字符串格式化的功能。基本语法是通过'{}'和':'来代替以前的'%'。format函数可以接受不限个参数，位置可以不按顺序。

  ```Python
  >>>"{} {}".format("hello", "world") # 不设置指定位置按默认顺序
  'hello world'
  >>> "{1} {0} {1}".format("hello", "world") # 设置指定位置
  'world hello world'
  ```

  * 也可以设置参数：

  ```Python
  # 通过关键词设置参数
  print("网站名：{name}, 地址 {url}".format(name="w3cschool教程", url="www.w3cschool.cn"))
  # 通过字典设置参数
  site = {"name": "w3cschool教程", "url": "www.w3cschool.cn"}
  print("网站名：{name}, 地址 {url}".format(**site))
  # 通过列表索引设置参数
  my_list = ['w3cschool教程', 'www.w3cschool.cn']
  print("网站名：{0[0]}, 地址 {0[1]}".format(my_list)) # "0" 是必须的
  ```

  * 也可以向 str.format() 传入对象：

  ```Python
  class AssignValue(object):
      def __init__(self, value):
          self.value = value
  my_value = AssignValue(6)
  print('value 为: {0.value}'.format(my_value))  # "0" 是可选的
  ```

  * 数字格式化，下表展示了 str.format() 格式化数字的多种方法：

  ```Python
  >>> print("{:.2f}".format(3.1415926))
  3.14
  ```

  | 数字 | 格式 | 输出 | 描述 |
  | --- | --- | --- | --- |
  | 3.1415926 | {:.2f} | 3.14 | 保留小数点后两位 |
  | 3.1415926 | {:+.2f} | +3.14 | 带符号保留小数点后两位 |
  | -1 | {:+.2f} | -1.00 | 带符号保留小数点后两位 |
  | 2.71828 | {:.0f} | 3 | 不带小数 |
  | 5 | {:0>2d} | 05 | 数字补零 (填充左边宽度为2) |
  | 5 | {:x<4d} | 5xxx | 数字补x (填充右边, 宽度为4) |
  | 10 | {:x<4d} | 10xx | 数字补x (填充右边, 宽度为4) |
  | 1000000 | {:,} | 1,000,000 | 以逗号分隔的数字格式 |
  | 0.25 | {:.2%} | 25.00% | 百分比格式 |
  | 1000000000 | {:.2e} | 1.00e+09 | 指数记法 |
  | 13 | {:>10d} |     13 | 右对齐 (默认, 宽度为10) |
  | 13 | {:<10d} | 13 | 左对齐 (宽度为10) |
  | 13 | {:^10d} |   13 | 中间对齐 (宽度为10) |
  | 11 | '{:b}'.format(11)<br>'{:d}'.format(11)<br>'{:o}'.format(11)<br>'{:x}'.format(11)<br>'{:#x}'.format(11)<br>'{:#X}'.format(11) | 1011<br>11<br>13<br>b<br>0xb<br>0XB | 进制 |

  * ^, <, > 分别是居中、左对齐、右对齐，后面带宽度， : 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。+ 表示在正数前显示 +，负数前显示 -；（空格）表示在正数前加空格，b、d、o、x 分别是二进制、十进制、八进制、十六进制。此外我们可以使用大括号 {} 来转义大括号。
  * 在Python2中普通字符串是以8位ASCII码进行存储的，而Unicode字符串则存储为16位unicode字符串，这样能够表示更多的字符集。使用的语法是在字符串前面加上前缀u。在Python3中所有的字符串都是Unicode字符串。

### 文本函数

  | 函数 | 描述 |
  | --- | --- |
  | str.lower() | 转换字符串中的大写字符为小写 |
  | str.upper() | 转换字符串中的小写字母为大写 |
  | str.swapcase() | 将字符串中大写转换为小写，小写转换为大写 |
  | str.capitalize() | 将字符串的第一个字符转换为大写 |
  | str.title() | 返回"标题化"的字符串，就是说所有单词都是以大写开始，其余字母均为小写(见 istitle()) |
  | str.center(width[, fillchar]) | 返回一个指定的宽度width居中的字符串，fillchar为填充的字符默认为空格 |
  | str.count(sub, start=0, end=len(string)) | 返回sub在str里面出现的次数，如果start或者end指定则返回指定范围内sub出现的次数 |
  | bytes.decode(encoding="utf-8", errors="strict") | Python3中没有decode方法，但我们可以使用bytes对象的decode()方法来解码给定的bytes对象，这个bytes对象可以由str.encode()来编码返回 |
  | str.encode(encoding='UTF-8', errors='strict') | 以encoding指定的编码格式编码字符串，如果出错默认报ValueError异常，除非errors指定的是'ignore'或者'replace' |
  | str.startswith(substr, start=0, end=len(string)) | 检查字符串是否是以指定子字符串开头，是则返回True否则返回False。如果start和end指定值则在指定范围内检查 |
  | str.endswith(suffix, start=0, end=len(string)) | 检查字符串是否以指定的字符串结束，如果start或者end指定则检查指定的范围内是否以指定的字符串结束，如果是返回True否则返回False |
  | str.expandtabs(tabsize=8) | 把字符串str中的tab符号转为空格，tab符号默认的空格数是8 |

  | str.find(str, start=0, end=len(string)) | 检测str是否包含在字符串中，如果指定范围start和end，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1 |
  | str.index(str, start=0, end=len(string)) | 跟find()方法一样只不过如果str不在字符串中会报一个异常 |
  | str.rfind(str, start=0, end=len(string)) | 类似于find()函数不过是从右边开始查找 |
  | str.rindex(str, start=0, end=len(string)) | 类似于index()不过是从右边开始 |

  | str.isalnum() | 如果字符串至少有一个字符并且所有字符都是字母或数字则返回True，否则返回False |
  | str.isalpha() | 如果字符串至少有一个字符并且所有字符都是字母或中文字则返回True，否则返回False |
  | str.isdigit() | 如果字符串只包含数字则返回True否则返回False |
  | str.isdecimal() | 检查字符串是否只包含十进制字符，如果是返回True否则返回False |
  | str.islower() | 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写则返回True，否则返回False |
  | str.isnumeric() | 如果字符串中只包含数字字符则返回True，否则返回False |
  | str.isspace() | 如果字符串中只包含空白则返回True，否则返回False |
  | str.istitle() | 如果字符串是标题化的(见title())则返回True，否则返回False |
  | str.isupper() | 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写则返回True，否则返回False |

  | str.join(seq) | 以指定字符串作为分隔符，将seq中所有的元素(的字符串表示)合并为一个新的字符串 |
  | str.ljust(width[, fillchar]) | 返回一个原字符串左对齐并使用fillchar（默认空格）填充至长度width的新字符串 |
  | str.rjust(width[, fillchar]) | 返回一个原字符串右对齐并使用fillchar（默认空格）填充至长度width的新字符串 |
  
  | str.lstrip([chars]) | 截掉字符串左边的空格或指定字符 |
  | str.rstrip([chars]) | 删除字符串末尾的空格或指定字符 |
  | str.strip([chars]) | 在字符串上执行lstrip()和rstrip() |
  | str.replace(old, new[, max]) | 把将字符串中的old替换成new，如果max指定则替换不超过max次 |
  | str.split(str="", num=string.count(str)) | 以str为分隔符截取字符串，如果num有指定值则仅截取num+1个子字符串 |
  | str.splitlines([keepends]) | 按照行('\r', '\r\n', \n')分隔，返回一个包含各行作为元素的列表，如果参数keepends为False，不包含换行符，如果为True，则保留换行符 |
  | str.zfill(width) | 返回长度为width的字符串，原字符串右对齐，前面填充0 |
  | str.maketrans(intab, outtab) | 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串表示需要转换的字符，第二个参数也是字符串表示转换的目标 |
  | str.translate(table, deletechars="") | 根据table给出的表(包含256个字符)转换str的字符, 要过滤掉的字符放到deletechars参数中 |

## 容器类型

### 列表元祖

  * 1.写在方括号'[]'之间、元素之间用逗号隔开，列表中元素类型可不同（这点是与其他语言的数组的一个区别），元素是可以修改的，支持索引、切片、相加和相乘操作；将列表当做堆栈使用，最先进入的元素最后一个被释放（后进先出），用append()方法可以把一个元素添加到堆栈顶，用不指定索引的pop()方法可以把一个元素从堆栈顶释放出来；将列表当作队列使用，只是在队列里第一加入的元素第一个取出来，但是拿列表用作这样的目的效率不高，在列表的最后添加或者弹出元素速度快，然而在列表里插入或者从头部弹出速度却不快（因为所有其他的元素都得一个一个地移动）；使用del语句可以从一个列表中根据索引来删除一个元素而不是值来删除元素，这与使用pop()返回一个值不同，可以用del语句从列表中删除一个切割或清空整个列表（我们以前介绍的方法是给该切割赋一个空列表）"del a[0]"，"del a[2:4]"，"del a[:]"，"del a"。
  * 2.写在小括号'()'之间、元素之间用逗号隔开，元组中的元素类型可不同且元素不能修改，支持索引、切片、相加和相乘操作。构造包含0个或1个元素的元组是个特殊的问题，所以有一些额外的语法规则："tup1 = ()"空元组，"tup2 = (20, )"一个元素需要在元素后添加逗号。"tup3 = 'a', 'b', 'c', 'd'"不需要括号也可以。元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组。可以把字符串看作一种特殊的元组。

  ```Python
  # 遍历时索引位置和对应值可以使用enumerate()函数同时得到：
  >>> for i, v in enumerate(['tic', 'tac', 'toe']):
  ...     print(i, v)
  0 tic
  1 tac
  2 toe
  # 同时遍历两个或更多的序列可以使用zip()组合：
  >>> questions = ['name', 'quest', 'favorite color']
  >>> answers = ['lancelot', 'the holy grail', 'blue']
  >>> for q, a in zip(questions, answers):
  ...     print('What is your {0}?  It is {1}.'.format(q, a))
  What is your name?  It is lancelot.
  What is your quest?  It is the holy grail.
  What is your favorite color?  It is blue.
  # 嵌套列表解析，以下实例展示了3X4的矩阵列表：
  >>> matrix = [[1, 2, 3, 4],
  ...           [5, 6, 7, 8],
  ...           [9, 10, 11, 12]]
  # 以下实例将3X4的矩阵列表转换为4X3列表：
  >>> [[row[i] for row in matrix] for i in range(4)]
  [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
  ```

  | 函数 | 描述 |
  | --- | --- |
  | list.append(obj) | 在列表末尾添加新的对象 |
  | list.count(obj) | 统计某个元素在列表中出现的次数 |
  | list.extend(seq) | 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） |
  | list.index(obj) | 从列表中找出某个值第一个匹配项的索引位置 |
  | list.insert(index, obj) | 在列表的index的地方插入一个对象 |
  | list.pop([index=-1]) | 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 |
  | list.remove(obj) | 移除列表中某个值的第一个匹配项 |
  | list.reverse() | 将反向排列列表中元素 |
  | list.sort(key=None, reverse=False) | 对原列表进行排序 |
  | list.clear() | 清空列表 |
  | list.copy() | 复制列表 |

### 集合类型
  
  * 1.集合是一个无序不重复元素的序列，基本功能是进行成员关系测试和消除重复元素，因此在每次运行的时候集合的运行结果的内容都是相同的，但元素的排列顺序却不是固定的。可以使用大括号'{}'或者set()函数创建集合，创建一个空集合必须用set()而不是'{}'，因为'{}'是用来创建一个空字典。

  ```Python
  # 集合可以进行求并集、交集、差集以及对称差运算：
  >>> a = set('abracadabra')
  >>> b = set('alacazam')
  >>> a - b                              # 差集，集合a中包含而集合b中不包含的元素
  {'r', 'd', 'b'}
  >>> a | b                              # 并集，集合a或b中包含的所有元素
  {'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
  >>> a & b                              # 交集，集合a和b中都包含了的元素
  {'a', 'c'}
  >>> a ^ b                              # 异或集，不同时包含于a和b的元素
  {'r', 'd', 'b', 'm', 'z', 'l'}
  ```

  | 函数 | 描述 |
  | --- | --- |
  | set.add() | 为集合添加元素 |
  | set.clear() | 移除集合中的所有元素 |
  | set.copy() | 拷贝一个集合 |
  | set.difference() | 返回多个集合的差集 |
  | set.difference_update() | 移除集合中的元素，该元素在指定的集合也存在 |
  | set.discard() | 删除集合中指定的元素，不存在不会发生错误 |
  | set.intersection() | 返回集合的交集 |
  | set.intersection_update() | 返回集合的交集 |
  | set.isdisjoint() | 判断两个集合是否包含相同的元素，如果没有返回True否则返回False |
  | set.issubset() | 判断指定集合是否为该方法参数集合的子集 |
  | set.issuperset() | 判断该方法的参数集合是否为指定集合的子集 |
  | set.pop() | 随机移除元素，会对集合进行无序的排列，然后将这个无序排列集合的左面第一个元素进行删除 |
  | set.remove() | 移除指定元素，不存在会发生错误 |
  | set.symmetric_difference() | 返回两个集合中不重复的元素集合 |
  | set.symmetric_difference_update() | 移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中 |
  | set.union() | 返回两个集合的并集 |
  | set.update() | 给集合添加元素 |

### 字典类型

  * 1.字典是一种映射类型（mapping type），它是一个无序的键值对（key-value）集合，在同一个字典中，关键字（key）必须互不相同，创建时如果同一个键被赋值两次后一个值会被记住。关键字（key）必须使用不可变类型，也就是说list和包含可变类型的tuple不能做关键字。向字典添加新内容的方法是增加新的键/值对，字典值可以是任何对象，既可以是标准的对象也可以是用户定义的，但键不行。

  ```Python
  # 构造函数dict()直接从键值对sequence中构建字典，当然也可以进行推导：
  >>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
  {'jack': 4098, 'sape': 4139, 'guido': 4127}
  >>> dict(sape=4139, guido=4127, jack=4098)
  {'jack': 4098, 'sape': 4139, 'guido': 4127}

  # 遍历时关键字和对应的值可以使用items()方法同时解读出来：
  >>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
  >>> for k, v in knights.items():
  ...     print(k, v)
  ```

  | 函数 | 描述 |
  | --- | --- |
  | dict.clear() | 删除字典内所有元素 |
  | dict.copy() | 返回一个字典的浅复制 |
  | dict.fromkeys() | 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值 |
  | dict.get(key, default=None) | 返回指定键的值，如果键不在字典中返回 default 设置的默认值 |
  | dict.items() | 以列表返回可遍历的(键, 值) 元组数组 |
  | dict.keys() | 以列表返回一个字典所有的键 |
  | dict.values() | 以列表返回字典中的所有值 |
  | dict.setdefault(key, default=None) | 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default |
  | dict.update(dict2) | 把字典dict2的键/值对更新到dict里 |
  | dict.pop(key[,default]) | 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则返回default值 |
  | dict.popitem() | 返回并删除字典中的最后一对键和值 |


<!-- ##  数据结构 算法

## 标准库  输入和输出 file , os 文件和目录

## 各版本新特性
3.8  海象操作符、 f-string、 强制位置参数

f-string
f-string 是 python3.6 之后版本添加的，称之为字面量格式化字符串，是新的格式化字符串的语法。

之前我们习惯用百分号 (%):

实例
>>> name = 'Runoob'
>>> 'Hello %s' % name
'Hello Runoob'
f-string 格式化字符串以 f 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去，实例如下：

实例
>>> name = 'Runoob'
>>> f'Hello {name}'  # 替换变量
'Hello Runoob'
>>> f'{1+2}'         # 使用表达式
'3'

>>> w = {'name': 'Runoob', 'url': 'www.runoob.com'}
>>> f'{w["name"]}: {w["url"]}'
'Runoob: www.runoob.com'
用了这种方式明显更简单了，不用再去判断使用 %s，还是 %d。

在 Python 3.8 的版本中可以使用 = 符号来拼接运算表达式与结果：

实例
>>> x = 1
>>> print(f'{x+1}')   # Python 3.6
2

>>> x = 1
>>> print(f'{x+1=}')   # Python 3.8
x+1=2


## 主要模块
thread/asyncio，cgi/uWSGI, socket/SMTP
numpy/pandas SciPy/Scikit-Learn tensorflow/pytorch pytest/unittest 
pillow/pyqt/ansible  flask/quart/scrapy



#############
Python语言应用领域(按热门程度排序)：
一．数据分析
  数据处理，分析，可视化
二．Web开发
  后端开发
三．机器学习
  人工智能，语言识别和处理，视频/图像/语音识别和处理
四．数据采集
  网络爬虫
五．运维测试
  服务器应用部署，软件接口测试 -->




